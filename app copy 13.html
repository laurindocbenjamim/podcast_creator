<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Waveform Video Creator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* CSS Variables based on your provided model */
        :root {
            --clr-dark-a0: #000000;
            --clr-light-a0: #ffffff;

            --clr-primary-a0: #61fd2d;
            --clr-primary-a10: #7bfe4f;
            --clr-primary-a20: #91ff6a;
            --clr-primary-a30: #a4ff81;
            --clr-primary-a40: #b6ff97;
            --clr-primary-a50: #c6ffac;

            --clr-surface-a0: #121212;
            --clr-surface-a10: #282828;
            --clr-surface-a20: #3f3f3f;
            --clr-surface-a30: #575757;
            --clr-surface-a40: #717171;
            --clr-surface-a50: #8b8b8b;

            --clr-surface-tonal-a0: #1c2618;
            --clr-surface-tonal-a10: #313a2d;
            --clr-surface-tonal-a20: #485044;
            --clr-surface-tonal-a30: #5f675c;
            --clr-surface-tonal-a40: #787e75;
            --clr-surface-tonal-a50: #91978f;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--clr-dark-a0);
            color: var(--clr-light-a0);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better content flow */
            min-height: 100vh;
            padding: 2rem 1rem; /* Add some padding for smaller screens */
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 4xl; /* Equivalent to Tailwind's max-w-4xl */
            background-color: var(--clr-surface-a0);
            padding: 2rem;
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
        }

        h1 {
            font-size: 2.25rem; /* text-4xl */
            font-weight: 700; /* font-bold */
            text-align: center;
            color: var(--clr-light-a0);
            margin-bottom: 2rem;
        }

        .section-card {
            margin-bottom: 1.5rem; /* mb-6 */
            padding: 1rem; /* p-4 */
            border: 1px solid var(--clr-surface-a10);
            border-radius: 0.5rem; /* rounded-lg */
            background-color: var(--clr-surface-a10);
        }

        label {
            display: block;
            font-size: 1.125rem; /* text-lg */
            font-weight: 500; /* font-medium */
            color: var(--clr-light-a0);
            margin-bottom: 0.5rem;
        }

        input[type="file"],
        input[type="text"],
        select,
        input[type="color"],
        textarea { /* Added textarea to styling */
            display: block;
            width: 100%;
            padding: 0.5rem 0.75rem; /* py-2 px-3 */
            margin-top: 0.25rem; /* mt-1 */
            border: 1px solid var(--clr-surface-a30);
            background-color: var(--clr-surface-a20);
            color: var(--clr-light-a0);
            border-radius: 0.375rem; /* rounded-md */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            outline: none; /* Remove default focus outline */
        }

        textarea {
            min-height: 5rem; /* Added min-height for textareas */
            resize: vertical; /* Allow vertical resizing */
        }

        input[type="file"]::-webkit-file-upload-button {
            margin-right: 1rem; /* file:mr-4 */
            padding: 0.5rem 1rem; /* file:py-2 file:px-4 */
            border-radius: 0.375rem; /* file:rounded-md */
            border: 0;
            font-size: 0.875rem; /* file:text-sm */
            font-weight: 600; /* file:font-semibold */
            background-color: var(--clr-primary-a0); /* file:bg-primary-a0 */
            color: var(--clr-dark-a0); /* file:text-dark-a0 */
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }

        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: var(--clr-primary-a10); /* hover:file:bg-primary-a10 */
        }

        input[type="color"] {
            height: 2.5rem; /* h-10 */
            padding: 0; /* Remove padding for color input */
            border: 1px solid var(--clr-surface-a30); /* Ensure border for color input */
        }

        select {
            padding-right: 2.5rem; /* pr-10 for dropdown arrow */
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none'%3e%3cpath d='M7 7l3 3 3-3m0 6l-3-3-3 3' stroke='white' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.5em 1.5em;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .flex-center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .space-x-4 > *:not(:first-child) {
            margin-left: 1rem; /* space-x-4 */
        }

        /* Customized Play/Pause Button Styling */
        .play-pause-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem; /* p-3 */
            background-color: var(--clr-primary-a0);
            color: var(--clr-dark-a0);
            border-radius: 0.375rem; /* rounded-md */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            transform: scale(1);
            outline: none;
            border: none;
            cursor: pointer;
        }

        .play-pause-button:hover {
            background-color: var(--clr-primary-a10);
            transform: scale(1.05);
        }

        .play-pause-button:focus {
            box-shadow: 0 0 0 2px var(--clr-primary-a0), 0 0 0 4px rgba(97, 253, 45, 0.5); /* focus:ring-2 focus:ring-primary-a0 focus:ring-offset-2 */
        }

        .play-pause-button svg {
            width: 1.5rem; /* w-6 */
            height: 1.5rem; /* h-6 */
        }

        .text-gray-300 { color: #d1d5db; }
        .text-gray-400 { color: #9ca3af; }
        .text-red-300 { color: #fca5a5; }

        .canvas-container {
            width: 100%;
            height: auto;
            background-color: var(--clr-surface-a0);
            border-radius: 0.375rem; /* rounded-md */
            border: 1px solid var(--clr-surface-a20);
        }

        .grid-cols-2 {
            display: grid;
            grid-template-columns: repeat(1, minmax(0, 1fr));
            gap: 1.5rem; /* gap-6 */
        }

        @media (min-width: 768px) { /* md: breakpoint */
            .grid-cols-2 {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
            .md\:col-span-2 {
                grid-column: span 2 / span 2;
            }
        }

        .text-center {
            text-align: center;
        }

        .generate-button {
            padding: 0.75rem 2rem; /* px-8 py-3 */
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* font-semibold */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
            transition: background-color 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: scale(1);
            outline: none;
            border: none;
            color: var(--clr-dark-a0);
            background-color: var(--clr-primary-a0);
        }

        .generate-button:hover:not(:disabled) {
            background-color: var(--clr-primary-a10);
            transform: scale(1.05);
        }

        .generate-button:focus:not(:disabled) {
            box-shadow: 0 0 0 2px var(--clr-primary-a0), 0 0 0 4px rgba(97, 253, 45, 0.5);
        }

        .generate-button:disabled {
            background-color: var(--clr-surface-a30);
            color: var(--clr-surface-a50);
            cursor: not-allowed;
        }

        .progress-bar-container {
            margin-top: 1rem; /* mt-4 */
            width: 100%;
            max-width: 24rem; /* max-w-sm */
            margin-left: auto;
            margin-right: auto;
        }

        .progress-bar-bg {
            width: 100%;
            background-color: var(--clr-surface-a20);
            border-radius: 9999px; /* rounded-full */
            height: 0.625rem; /* h-2.5 */
        }

        .progress-bar-fill {
            background-color: var(--clr-primary-a0);
            height: 0.625rem;
            border-radius: 9999px;
            transition: width 0.3s ease-out;
        }

        .download-link {
            display: inline-flex;
            align-items: center;
            padding: 0.75rem 1.5rem; /* px-6 py-3 */
            border: 1px solid transparent;
            font-size: 1rem; /* text-base */
            font-weight: 500; /* font-medium */
            border-radius: 0.375rem; /* rounded-md */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            color: var(--clr-dark-a0);
            background-color: var(--clr-primary-a0);
            transition: background-color 0.2s ease-in-out;
            outline: none;
        }

        .download-link:hover {
            background-color: var(--clr-primary-a10);
        }

        .download-link:focus {
            box-shadow: 0 0 0 2px var(--clr-primary-a0), 0 0 0 4px rgba(97, 253, 45, 0.5);
        }

        .download-link svg {
            margin-left: 0.5rem; /* ml-2 */
            margin-right: -0.125rem; /* -mr-0.5 */
            height: 1.25rem; /* h-5 */
            width: 1.25rem; /* w-5 */
        }

        /* Popup Error Alert Styling */
        .error-alert {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background-color: #ef4444; /* Tailwind red-500 */
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            z-index: 1000; /* Ensure it's on top */
        }

        .error-alert.show {
            opacity: 1;
            visibility: visible;
        }

        .error-alert-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
            padding: 0.25rem;
            border-radius: 0.25rem;
        }

        .error-alert-close:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* Checkbox styling */
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-top: 0.5rem;
        }

        .checkbox-container input[type="checkbox"] {
            width: 1.25rem; /* w-5 */
            height: 1.25rem; /* h-5 */
            margin-right: 0.5rem; /* mr-2 */
            accent-color: var(--clr-primary-a0); /* Custom color for checkbox */
            cursor: pointer;
            display: inline-block; /* Override display: block from general input styles */
            box-shadow: none; /* Remove shadow for checkbox */
            border: 1px solid var(--clr-surface-a30); /* Ensure border */
            background-color: var(--clr-surface-a20); /* Background for unchecked state */
            border-radius: 0.25rem; /* slightly rounded corners */
        }

        .checkbox-container label {
            margin-bottom: 0; /* Remove bottom margin from label */
            display: inline; /* Keep label inline with checkbox */
            font-size: 0.875rem; /* text-sm */
            font-weight: 400; /* font-normal */
            color: var(--clr-gray-300); /* text-gray-300 */
            cursor: pointer;
        }

        .ai-button-group {
            display: flex;
            gap: 0.5rem; /* space-x-2 */
            margin-top: 0.5rem;
            justify-content: flex-end; /* Align buttons to the right */
        }

        .ai-button {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 600;
            border-radius: 0.375rem;
            background-color: var(--clr-primary-a0);
            color: var(--clr-dark-a0);
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }

        .ai-button:hover:not(:disabled) {
            background-color: var(--clr-primary-a10);
            transform: translateY(-2px);
        }

        .ai-button:disabled {
            background-color: var(--clr-surface-a30);
            color: var(--clr-surface-a50);
            cursor: not-allowed;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--clr-primary-a0);
            border-radius: 50%;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Audio Waveform Video Creator</h1>

        <div class="section-card">
            <label for="audio-upload">1. Select Audio File or Record from Microphone</label>
            <input type="file" id="audio-upload" accept="audio/*">
            
            <div id="audio-controls" style="margin-top: 1rem; display: flex; align-items: center; gap: 1rem;">
                <audio id="audio-player" controls="false" style="display: none;"></audio>
                
                <button id="rewind-button" class="play-pause-button" title="Rewind 5 seconds">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11 17l-5-5 5-5M18 17l-5-5 5-5"/></svg>
                </button>
                
                <button id="toggle-play-pause" class="play-pause-button" title="Play Audio">
                    <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style="display: none;"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                </button>
                
                <button id="forward-button" class="play-pause-button" title="Forward 5 seconds">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M13 17l5-5-5-5M6 17l5-5-5-5"/></svg>
                </button>

                <select id="playback-speed" style="margin-left: 1rem; width: auto; flex-shrink: 0;">
                    <option value="0.5">0.5x</option>
                    <option value="0.75">0.75x</option>
                    <option value="1" selected>1x (Normal)</option>
                    <option value="1.25">1.25x</option>
                    <option value="1.5">1.5x</option>
                    <option value="2">2x</option>
                </select>

                <span id="audio-file-name" class="text-gray-300" style="margin-left: 1rem; flex-grow: 1;">No audio selected</span>
            </div>

            <div style="margin-top: 1rem; display: flex; align-items: center; gap: 1rem;">
                <button id="record-button" class="play-pause-button" title="Record Audio from Microphone">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"></path><path d="M19 10v2a7 7 0 01-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                    Record
                </button>
                <button id="stop-record-button" class="play-pause-button" title="Stop Recording" style="display: none; background-color: #dc2626;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
                    Stop
                </button>
                <span id="recording-status" class="text-gray-400 text-sm"></span>
            </div>
            
            <div class="checkbox-container">
                <input type="checkbox" id="record-without-pause">
                <label for="record-without-pause">Record without pausing playback</label>
            </div>

            <p id="message" class="text-red-300 text-sm" style="margin-top: 0.5rem;"></p>
        </div>

        <div class="section-card">
            <h2 class="text-lg font-medium text-white mb-2">Waveform Preview</h2>
            <canvas id="waveform-canvas" width="800" height="400" class="canvas-container"></canvas>
            <div id="audio-playback-progress-container" class="progress-bar-container" style="margin-top: 1rem;">
                <div class="progress-bar-bg" style="cursor: pointer;">
                    <div id="audio-playback-progress-fill" class="progress-bar-fill" style="width: 0%;"></div>
                </div>
                <div class="flex justify-between text-xs text-gray-400 mt-1">
                    <span id="current-time">0:00</span>
                    <span id="total-duration">0:00</span>
                </div>
            </div>
            <div style="margin-top: 1rem; display: flex; justify-content: center; gap: 1rem;">
                <button id="switch-to-uploaded-audio" class="play-pause-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18V5l12-2v13M9 18a3 3 0 100-6 3 3 0 000 6zM21 17v5l-12-2v-9M21 17a3 3 0 100-6 3 3 0 000 6z"/></svg>
                    Use Uploaded
                </button>
                <button id="switch-to-recorded-audio" class="play-pause-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"></path><path d="M19 10v2a7 7 0 01-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                    Use Recorded
                </button>
                <a id="download-active-audio-link" href="#" download="audio.webm" class="download-link" style="display: none;">
                    Download Audio
                    <svg class="ml-2 -mr-0.5 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                        <path fill-rule="evenodd" d="M10 3a.75.75 0 01.75.75v10.638l3.96-4.158a.75.75 0 111.08 1.04l-5.25 5.5a.75.75 0 01-1.08 0l-5.25-5.5a.75.75 0 111.08-1.04l3.96 4.158V3.75A.75.75 0 0110 3z" clip-rule="evenodd" />
                    </svg>
                </a>
            </div>
        </div>

        <div class="section-card grid-cols-2">
            <div>
                <label for="waveform-style">3. Waveform Style</label>
                <select id="waveform-style">
                    <option value="bars">Bars</option>
                    <option value="lines">Lines</option>
                    <option value="circles">Circles</option>
                    <option value="frequency-bars">Frequency Bars</option>
                    <option value="smooth-lines">Smooth Lines</option>
                </select>
            </div>
            <div>
                <label for="waveform-color">Waveform Color</label>
                <input type="color" id="waveform-color" value="#61fd2d">
            </div>
            <div>
                <label for="background-color">Background Color</label>
                <input type="color" id="background-color" value="#121212">
            </div>
            <div>
                <label for="background-opacity">Background Opacity</label>
                <input type="range" id="background-opacity" min="0" max="1" step="0.01" value="1" class="accent-[var(--clr-primary-a0)]">
                <span id="background-opacity-value" class="text-sm text-gray-400">100%</span>
            </div>
            <div>
                <label for="background-image">4. Background Image (Optional)</label>
                <input type="file" id="background-image" accept="image/*">
                <img id="background-image-preview" style="margin-top: 0.5rem; width: 6rem; height: 6rem; object-fit: cover; border-radius: 0.375rem; display: none;">
            </div>
            <div class="md:col-span-2">
                <label for="text-overlay">5. Text/Branding</label>
                <input type="text" id="text-overlay" value="Your Title Here" placeholder="Enter text for overlay">
            </div>
        </div>

        <div class="section-card">
            <h2 class="text-lg font-medium text-white mb-2">AI-Powered Enhancements</h2>
            <div>
                <label for="podcast-description">Podcast Description</label>
                <textarea id="podcast-description" rows="4" placeholder="Generated podcast description will appear here..."></textarea>
                <div class="ai-button-group">
                    <button id="generate-description-button" class="ai-button">Generate Description ✨</button>
                    <span id="description-loading-spinner" class="loading-spinner" style="display: none;"></span>
                </div>
            </div>
            <div style="margin-top: 1rem;">
                <label for="suggested-hashtags">Suggested Hashtags</label>
                <textarea id="suggested-hashtags" rows="2" placeholder="Generated hashtags will appear here..."></textarea>
                <div class="ai-button-group">
                    <button id="generate-hashtags-button" class="ai-button">Generate Hashtags ✨</button>
                    <span id="hashtags-loading-spinner" class="loading-spinner" style="display: none;"></span>
                </div>
            </div>
        </div>

        <div class="text-center">
            <button id="generate-video-button" class="generate-button">6. Generate Video</button>
            <div id="generation-progress-container" class="progress-bar-container" style="display: none;">
                <div class="progress-bar-bg">
                    <div id="progress-bar-fill" class="progress-bar-fill" style="width: 0%;"></div>
                </div>
                <p id="generation-message" class="text-gray-400 text-sm" style="margin-top: 0.5rem;"></p>
            </div>
            <div id="download-section" style="margin-top: 1rem; display: none;">
                <p class="text-[var(--clr-light-a0)] mb-2">Video generation is simulated. The download link below provides a dummy file.</p>
                <a id="download-link" href="#" download="your_waveform_video.mp4" class="download-link">
                    Download Simulated Video
                    <svg class="ml-2 -mr-0.5 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                        <path fill-rule="evenodd" d="M10 3a.75.75 0 01.75.75v10.638l3.96-4.158a.75.75 0 111.08 1.04l-5.25 5.5a.75.75 0 01-1.08 0l-5.25-5.5a.75.75 0 111.08-1.04l3.96 4.158V3.75A.75.75 0 0110 3z" clip-rule="evenodd" />
                    </svg>
                </a>
            </div>
        </div>
    </div>

    <div id="error-alert" class="error-alert">
        <span id="error-alert-message"></span>
        <button id="error-alert-close" class="error-alert-close">&times;</button>
    </div>

    <script>
        // Helper function to convert hex color to RGBA string
        const hexToRgba = (hex, alpha) => {
            let r = 0, g = 0, b = 0;
            // Handle 3-digit hex
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            }
            // Handle 6-digit hex
            else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        };

        // Helper function to format time (seconds to MM:SS)
        const formatTime = (seconds) => {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        };

        // DOM Elements
        const audioUpload = document.getElementById('audio-upload');
        // The original audioPlayer element is now primarily a placeholder for the uploaded audio's initial state
        const audioPlayer = document.getElementById('audio-player'); 
        const togglePlayPauseButton = document.getElementById('toggle-play-pause');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const rewindButton = document.getElementById('rewind-button');
        const forwardButton = document.getElementById('forward-button');
        const audioFileNameSpan = document.getElementById('audio-file-name');
        const messageElement = document.getElementById('message');
        const waveformCanvas = document.getElementById('waveform-canvas');
        const waveformStyleSelect = document.getElementById('waveform-style');
        const waveformColorInput = document.getElementById('waveform-color');
        const backgroundColorInput = document.getElementById('background-color');
        const backgroundOpacityInput = document.getElementById('background-opacity');
        const backgroundOpacityValueSpan = document.getElementById('background-opacity-value');
        const backgroundImageInput = document.getElementById('background-image');
        const backgroundImagePreview = document.getElementById('background-image-preview');
        const textOverlayInput = document.getElementById('text-overlay');
        const generateVideoButton = document.getElementById('generate-video-button');
        const generationProgressContainer = document.getElementById('generation-progress-container');
        const progressBarFill = document.getElementById('progress-bar-fill');
        const generationMessage = document.getElementById('generation-message');
        const downloadSection = document.getElementById('download-section');
        const downloadLink = document.getElementById('download-link');
        const audioControls = document.getElementById('audio-controls');

        // New buttons for switching audio sources
        const switchToUploadedAudioButton = document.getElementById('switch-to-uploaded-audio');
        const switchToRecordedAudioButton = document.getElementById('switch-to-recorded-audio');
        const downloadActiveAudioLink = document.getElementById('download-active-audio-link'); // New download button for active audio

        // Audio Playback Progress Bar Elements
        const audioPlaybackProgressContainer = document.getElementById('audio-playback-progress-container');
        const audioPlaybackProgressFill = document.getElementById('audio-playback-progress-fill');
        const currentTimeSpan = document.getElementById('current-time');
        const totalDurationSpan = document.getElementById('total-duration');

        // Popup Error Alert Elements
        const errorAlert = document.getElementById('error-alert');
        const errorAlertMessage = document.getElementById('error-alert-message');
        const errorAlertCloseButton = document.getElementById('error-alert-close');

        // Playback Speed Element
        const playbackSpeedSelect = document.getElementById('playback-speed');

        // Microphone Recording Elements
        const recordButton = document.getElementById('record-button');
        const stopRecordButton = document.getElementById('stop-record-button');
        const recordingStatusSpan = document.getElementById('recording-status');
        const recordWithoutPauseCheckbox = document.getElementById('record-without-pause');

        // New AI-Powered Elements
        const podcastDescriptionTextarea = document.getElementById('podcast-description');
        const generateDescriptionButton = document.getElementById('generate-description-button');
        const descriptionLoadingSpinner = document.getElementById('description-loading-spinner');
        const suggestedHashtagsTextarea = document.getElementById('suggested-hashtags');
        const generateHashtagsButton = document.getElementById('generate-hashtags-button');
        const hashtagsLoadingSpinner = document.getElementById('hashtags-loading-spinner');


        // MediaRecorder variables
        let mediaRecorder;
        let audioChunks = [];
        let mediaStream; // To store the microphone stream


        // State variables
        let audioFile = null; // This will hold the File object for the video generation (either uploaded or recorded)
        let uploadedAudioUrl = ''; // URL for the uploaded audio file
        let recordedAudioUrl = ''; // URL for the recorded audio file
        let isPlaying = false;
        let waveformStyle = waveformStyleSelect.value;
        let waveformColor = waveformColorInput.value;
        let backgroundColor = backgroundColorInput.value;
        let backgroundOpacity = parseFloat(backgroundOpacityInput.value);
        let backgroundImage = '';
        let textOverlay = textOverlayInput.value;
        let isGenerating = false;
        let loadedBgImage = null;
        let errorAlertTimeout; // To store the timeout for auto-dismissing the alert
        let playbackSpeed = parseFloat(playbackSpeedSelect.value);

        // Web Audio API context and nodes
        let audioContext = null;
        let analyser = null;
        let sourceNode = null;

        // This will point to the currently active audio element (either currentUploadedAudioElement or currentRecordedAudioElement)
        let activeAudioElement = null;
        // Store the actual file/blob for uploaded and recorded audio separately
        let uploadedAudioFileBlob = null;
        let recordedAudioFileBlob = null;

        // Dynamically created audio elements for uploaded and recorded audio
        let currentUploadedAudioElement = null;
        let currentRecordedAudioElement = null;

        // Function to show the error alert
        const showErrorAlert = (message) => {
            errorAlertMessage.textContent = message;
            errorAlert.classList.add('show');

            // Clear any existing timeout and set a new one to auto-dismiss
            clearTimeout(errorAlertTimeout);
            errorAlertTimeout = setTimeout(() => {
                errorAlert.classList.remove('show');
            }, 5000); // Dismiss after 5 seconds
        };

        // Function to hide the error alert
        const hideErrorAlert = () => {
            errorAlert.classList.remove('show');
            clearTimeout(errorAlertTimeout); // Clear timeout if dismissed manually
        };

        // Function to update the canvas display (background and text)
        const updateCanvasDisplay = () => {
            if (!waveformCanvas) return;

            const ctx = waveformCanvas.getContext('2d');
            const width = waveformCanvas.width;
            const height = waveformCanvas.height;

            ctx.clearRect(0, 0, width, height); // Clear the entire canvas

            // Draw background image or color with opacity
            if (loadedBgImage) {
                ctx.drawImage(loadedBgImage, 0, 0, width, height);
            } else {
                ctx.fillStyle = hexToRgba(backgroundColor, backgroundOpacity);
                ctx.fillRect(0, 0, width, height);
            }

            // Draw text overlay
            ctx.fillStyle = 'white';
            ctx.font = '24px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(textOverlay, width / 2, 30);

            // If audio is playing and analyser is ready, draw waveform visuals
            if (isPlaying && analyser && audioContext) {
                drawWaveformVisuals(ctx, width, height, analyser, waveformStyle, waveformColor, textOverlay);
                requestAnimationFrame(drawWaveform); // Continue animation loop
            }
        };

        // Function to draw the waveform on the canvas (now primarily for animation loop)
        const drawWaveform = () => {
            if (!waveformCanvas || !analyser || !audioContext) {
                return;
            }
            updateCanvasDisplay(); // Call the consolidated display update
        };

        // Helper function to draw the actual waveform visuals
        const drawWaveformVisuals = (ctx, width, height, analyserNode, style, color, text) => {
            const bufferLength = analyserNode.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyserNode.getByteFrequencyData(dataArray);

            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            let x = 0; 

            switch (style) {
                case 'bars':
                    const barWidth = (width / bufferLength) * 2.5;
                    x = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = dataArray[i] / 255 * height;
                        ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                        x += barWidth + 1;
                    }
                    break;
                case 'lines':
                    ctx.beginPath();
                    const sliceWidth = width * 1.0 / bufferLength;
                    x = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * height / 2;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        x += sliceWidth;
                    }
                    ctx.lineTo(width, height / 2);
                    ctx.stroke();
                    break;
                case 'circles':
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const maxRadius = Math.min(width, height) / 2 - 20;
                    for (let i = 0; i < bufferLength; i++) {
                        const radius = (dataArray[i] / 255) * maxRadius;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                    break;
                case 'frequency-bars':
                    const freqBarWidth = width / analyserNode.frequencyBinCount;
                    for (let i = 0; i < analyserNode.frequencyBinCount; i++) {
                        const barHeight = dataArray[i] * 2;
                        ctx.fillRect(i * freqBarWidth, height - barHeight, freqBarWidth * 0.8, barHeight);
                    }
                    break;
                case 'smooth-lines':
                    ctx.beginPath();
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    const segmentWidth = width / bufferLength;
                    x = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * height / 2;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        x += segmentWidth;
                    }
                    ctx.lineTo(width, height / 2);
                    ctx.stroke();
                    break;
                default:
                    break;
            }
        };

        // Function to attach timeupdate and loadedmetadata listeners to the active audio element
        const attachAudioListeners = () => {
            // Remove any existing listeners from previous active elements to prevent duplicates
            // This is crucial when switching active audio elements
            const allManagedAudioElements = [currentUploadedAudioElement, currentRecordedAudioElement];
            allManagedAudioElements.forEach(el => {
                if (el && el._timeUpdateListener) {
                    el.removeEventListener('timeupdate', el._timeUpdateListener);
                    el.removeEventListener('loadedmetadata', el._loadedMetadataListener);
                    el._timeUpdateListener = null;
                    el._loadedMetadataListener = null;
                }
            });

            if (activeAudioElement) {
                const timeUpdateListener = () => {
                    if (!isNaN(activeAudioElement.duration)) {
                        const progress = (activeAudioElement.currentTime / activeAudioElement.duration) * 100;
                        audioPlaybackProgressFill.style.width = `${progress}%`;
                        currentTimeSpan.textContent = formatTime(activeAudioElement.currentTime);
                    }
                };

                const loadedMetadataListener = () => {
                    totalDurationSpan.textContent = formatTime(activeAudioElement.duration);
                    currentTimeSpan.textContent = '0:00';
                    audioPlaybackProgressFill.style.width = '0%';
                };

                activeAudioElement.addEventListener('timeupdate', timeUpdateListener);
                activeAudioElement.addEventListener('loadedmetadata', loadedMetadataListener);

                // Store references to listeners for proper removal later
                activeAudioElement._timeUpdateListener = timeUpdateListener;
                activeAudioElement._loadedMetadataListener = loadedMetadataListener;

                // Also update playback speed if it's set
                activeAudioElement.playbackRate = playbackSpeed;

                activeAudioElement.onended = () => {
                    isPlaying = false;
                    playIcon.style.display = 'inline';
                    pauseIcon.style.display = 'none';
                    recordingStatusSpan.textContent = '';
                };
            }
        };

        // Centralized function to reset the audio visualization and controls for the *current* active element
        const resetVisualizationAndControls = () => {
            // Pause any currently playing audio
            if (activeAudioElement) {
                activeAudioElement.pause();
            }
            isPlaying = false;
            playIcon.style.display = 'inline';
            pauseIcon.style.display = 'none';
            currentTimeSpan.textContent = '0:00';
            totalDurationSpan.textContent = '0:00';
            audioPlaybackProgressFill.style.width = '0%';
            // audioFileNameSpan.textContent is updated by load functions, so no reset here
            messageElement.textContent = '';
            downloadSection.style.display = 'none';
            generationProgressContainer.style.display = 'none';
            
            // Disconnect and nullify Web Audio API nodes for visualization
            if (sourceNode) {
                sourceNode.disconnect();
                sourceNode = null;
            }
            if (analyser) {
                analyser = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            updateCanvasDisplay(); // Clear canvas
        };

        // Function to set up Web Audio API for a given audio element
        const setupWebAudioAPI = (audioEl) => {
            // Ensure any previous Web Audio API setup is cleared
            if (sourceNode) sourceNode.disconnect();
            if (audioContext) audioContext.close(); // Close the previous context

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            sourceNode = audioContext.createMediaElementSource(audioEl);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            sourceNode.connect(analyser);
            analyser.connect(audioContext.destination);
        };

        // Function to load and activate uploaded audio
        const loadUploadedAudio = (file) => {
            resetVisualizationAndControls(); // Reset visuals and controls

            uploadedAudioFileBlob = file; // Store the blob for video generation
            audioFile = uploadedAudioFileBlob; // Set the audioFile for video generation

            // Clean up previous dynamically created uploaded audio element if it exists
            if (currentUploadedAudioElement) {
                currentUploadedAudioElement.pause();
                URL.revokeObjectURL(currentUploadedAudioElement.src); // Revoke its object URL
                currentUploadedAudioElement.remove(); // Remove from DOM
                currentUploadedAudioElement = null;
            }

            // Create a brand new audio element for the uploaded file
            currentUploadedAudioElement = new Audio();
            currentUploadedAudioElement.src = URL.createObjectURL(file);
            currentUploadedAudioElement.playbackRate = playbackSpeed;
            currentUploadedAudioElement.style.display = 'none'; // Keep hidden
            document.body.appendChild(currentUploadedAudioElement); // Add to DOM

            // Pause the other audio element (recorded audio) if it exists
            if (currentRecordedAudioElement) {
                currentRecordedAudioElement.pause();
            }

            activeAudioElement = currentUploadedAudioElement; // Set active element
            setupWebAudioAPI(activeAudioElement); // Setup Web Audio API for it
            attachAudioListeners(); // Attach listeners
            audioFileNameSpan.textContent = file.name || 'Uploaded Audio';
            
            // Update the general download link for the active audio
            downloadActiveAudioLink.href = currentUploadedAudioElement.src;
            downloadActiveAudioLink.download = file.name ? `uploaded_audio_${file.name}` : 'uploaded_audio.webm';
            downloadActiveAudioLink.style.display = 'inline-flex';

            updateCanvasDisplay();
        };

        // Function to load and activate recorded audio
        const loadRecordedAudio = (blob) => {
            resetVisualizationAndControls(); // Reset visuals and controls

            recordedAudioFileBlob = blob; // Store the blob for video generation
            audioFile = recordedAudioFileBlob; // Set the audioFile for video generation

            // Clean up previous dynamically created recorded audio element if it exists
            if (currentRecordedAudioElement) {
                currentRecordedAudioElement.pause();
                URL.revokeObjectURL(currentRecordedAudioElement.src); // Revoke its object URL
                currentRecordedAudioElement.remove(); // Remove from DOM
                currentRecordedAudioElement = null;
            }

            // Create a brand new audio element for the recorded blob
            currentRecordedAudioElement = new Audio();
            currentRecordedAudioElement.src = URL.createObjectURL(blob);
            currentRecordedAudioElement.playbackRate = playbackSpeed;
            currentRecordedAudioElement.style.display = 'none'; // Keep hidden
            document.body.appendChild(currentRecordedAudioElement); // Add to DOM

            // Pause the other audio element (uploaded audio) if it exists
            if (currentUploadedAudioElement) {
                currentUploadedAudioElement.pause();
            }

            activeAudioElement = currentRecordedAudioElement; // Set active element
            setupWebAudioAPI(activeAudioElement); // Setup Web Audio API for it
            attachAudioListeners(); // Attach listeners
            audioFileNameSpan.textContent = 'Recorded Audio';

            // Update the general download link for the active audio
            downloadActiveAudioLink.href = currentRecordedAudioElement.src;
            downloadActiveAudioLink.download = 'recorded_audio.webm'; // Default name for recorded audio
            downloadActiveAudioLink.style.display = 'inline-flex';

            updateCanvasDisplay();
        };


        // Event Listeners
        audioUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file && file.type.startsWith('audio/')) {
                loadUploadedAudio(file);
            } else {
                resetVisualizationAndControls(); // Reset if invalid file
                showErrorAlert('Please select a valid audio file.');
                audioControls.style.display = 'none';
            }
        });

        togglePlayPauseButton.addEventListener('click', async () => {
            if (!activeAudioElement || !activeAudioElement.src) {
                showErrorAlert('Audio not ready. Please select an audio file or record one.');
                return;
            }

            if (audioContext && audioContext.state === 'suspended') {
                try {
                    await audioContext.resume();
                    console.log('AudioContext resumed.');
                } catch (e) {
                    console.error("AudioContext resume failed:", e);
                    showErrorAlert('Failed to resume audio. Browser might be preventing autoplay.');
                    return;
                }
            }

            if (activeAudioElement.paused) {
                try {
                    await activeAudioElement.play();
                    isPlaying = true;
                    playIcon.style.display = 'none';
                    pauseIcon.style.display = 'inline';
                    messageElement.textContent = '';
                    updateCanvasDisplay();
                }
                catch (e) {
                    console.error("Audio playback failed:", e);
                    showErrorAlert('Audio playback failed. Please ensure user interaction and try again.');
                    isPlaying = false;
                    playIcon.style.display = 'inline';
                    pauseIcon.style.display = 'none';
                }
            } else {
                activeAudioElement.pause();
                isPlaying = false;
                playIcon.style.display = 'inline';
                pauseIcon.style.display = 'none';
                messageElement.textContent = '';
            }
        });

        rewindButton.addEventListener('click', () => {
            if (activeAudioElement && activeAudioElement.src) {
                activeAudioElement.currentTime = Math.max(0, activeAudioElement.currentTime - 5);
            } else {
                showErrorAlert('No audio loaded to rewind.');
            }
        });

        forwardButton.addEventListener('click', () => {
            if (activeAudioElement && activeAudioElement.src) {
                activeAudioElement.currentTime = Math.min(activeAudioElement.duration, activeAudioElement.currentTime + 5);
            } else {
                showErrorAlert('No audio loaded to fast forward.');
            }
        });

        audioPlaybackProgressContainer.addEventListener('click', (event) => {
            if (!activeAudioElement || isNaN(activeAudioElement.duration)) {
                showErrorAlert('Please load an audio file first to seek.');
                return;
            }
            const progressBarRect = audioPlaybackProgressContainer.getBoundingClientRect();
            const clickX = event.clientX - progressBarRect.left;
            const newTime = (clickX / progressBarRect.width) * activeAudioElement.duration;
            activeAudioElement.currentTime = newTime;
        });

        playbackSpeedSelect.addEventListener('change', (event) => {
            playbackSpeed = parseFloat(event.target.value);
            if (activeAudioElement) {
                activeAudioElement.playbackRate = playbackSpeed;
            }
        });

        waveformStyleSelect.addEventListener('change', (event) => {
            waveformStyle = event.target.value;
            updateCanvasDisplay();
        });

        waveformColorInput.addEventListener('input', (event) => {
            waveformColor = event.target.value;
            updateCanvasDisplay();
        });

        backgroundColorInput.addEventListener('input', (event) => {
            backgroundColor = event.target.value;
            updateCanvasDisplay();
        });

        backgroundOpacityInput.addEventListener('input', (event) => {
            backgroundOpacity = parseFloat(event.target.value);
            backgroundOpacityValueSpan.textContent = `${Math.round(backgroundOpacity * 100)}%`;
            updateCanvasDisplay();
        });

        backgroundImageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const url = URL.createObjectURL(file);
                backgroundImage = url;
                messageElement.textContent = '';
                
                const img = new Image();
                img.src = url;
                img.onload = () => {
                    loadedBgImage = img;
                    backgroundImagePreview.src = url;
                    backgroundImagePreview.style.display = 'block';
                    updateCanvasDisplay();
                };
                img.onerror = () => {
                    console.error("Failed to load background image.");
                    loadedBgImage = null;
                    backgroundImage = '';
                    backgroundImagePreview.style.display = 'none';
                    showErrorAlert('Failed to load background image. Using background color instead.');
                    updateCanvasDisplay();
                };
            } else {
                backgroundImage = '';
                loadedBgImage = null;
                backgroundImagePreview.style.display = 'none';
                showErrorAlert('Please select a valid image file for the background.');
                updateCanvasDisplay();
            }
        });

        textOverlayInput.addEventListener('input', (event) => {
            textOverlay = event.target.value;
            updateCanvasDisplay();
        });

        // Microphone Recording Logic
        recordButton.addEventListener('click', async () => {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(mediaStream);
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    
                    loadRecordedAudio(audioBlob); // Load and activate recorded audio

                    recordingStatusSpan.textContent = 'Recording stopped. Audio loaded.';
                    recordButton.style.display = 'inline-flex';
                    stopRecordButton.style.display = 'none';
                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop()); // Stop microphone track
                    }
                };

                mediaRecorder.start();
                recordingStatusSpan.textContent = 'Recording...';
                recordButton.style.display = 'none';
                stopRecordButton.style.display = 'inline-flex';
                messageElement.textContent = ''; // Clear other messages

                // Conditional pause based on checkbox
                if (!recordWithoutPauseCheckbox.checked) {
                    if (activeAudioElement) {
                        activeAudioElement.pause(); // Pause any current playback
                        isPlaying = false; // Ensure playback state is false
                        playIcon.style.display = 'inline';
                        pauseIcon.style.display = 'none';
                    }
                }

            } catch (err) {
                console.error('Error accessing microphone:', err);
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    showErrorAlert('Microphone access denied. Please allow microphone access in your browser settings.');
                } else if (err.name === 'NotFoundError') {
                    showErrorAlert('No microphone found. Please ensure a microphone is connected and enabled.');
                } else {
                    showErrorAlert(`Error recording audio: ${err.message}`);
                }
                recordButton.style.display = 'inline-flex';
                stopRecordButton.style.display = 'none';
                recordingStatusSpan.textContent = '';
            }
        });

        stopRecordButton.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                recordingStatusSpan.textContent = 'Stopping recording...';
            }
        });

        // Switch audio source buttons
        switchToUploadedAudioButton.addEventListener('click', () => {
            if (uploadedAudioFileBlob) {
                loadUploadedAudio(uploadedAudioFileBlob);
            } else {
                showErrorAlert('No uploaded audio available. Please upload an audio file first.');
            }
        });

        switchToRecordedAudioButton.addEventListener('click', () => {
            if (recordedAudioFileBlob) {
                loadRecordedAudio(recordedAudioFileBlob);
            } else {
                showErrorAlert('No recorded audio available. Please record audio first.');
            }
        });


        // Gemini API Integration Functions
        const callGeminiAPI = async (prompt, loadingSpinner, outputTextarea) => {
            loadingSpinner.style.display = 'inline-block';
            outputTextarea.value = ''; // Clear previous output
            outputTextarea.placeholder = 'Generating...';
            
            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // Canvas will automatically provide this in runtime
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`API error: ${response.status} - ${errorData.error?.message || response.statusText}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    outputTextarea.value = text;
                    outputTextarea.placeholder = '';
                } else {
                    outputTextarea.value = 'Could not generate content. Please try again.';
                    outputTextarea.placeholder = '';
                    console.error('Unexpected API response structure:', result);
                }
            } catch (error) {
                console.error('Gemini API call failed:', error);
                showErrorAlert(`Gemini API Error: ${error.message}`);
                outputTextarea.value = 'Failed to generate content.';
                outputTextarea.placeholder = '';
            } finally {
                loadingSpinner.style.display = 'none';
            }
        };

        generateDescriptionButton.addEventListener('click', () => {
            const title = textOverlayInput.value.trim();
            if (!title) {
                showErrorAlert('Please enter a title in "Text/Branding" section to generate a description.');
                return;
            }
            const prompt = `Generate a short, engaging podcast description (around 50-100 words) based on the title: "${title}". Focus on what the podcast might be about and why someone would listen.`;
            callGeminiAPI(prompt, descriptionLoadingSpinner, podcastDescriptionTextarea);
        });

        generateHashtagsButton.addEventListener('click', () => {
            const description = podcastDescriptionTextarea.value.trim();
            if (!description) {
                showErrorAlert('Please generate a podcast description first to get hashtags.');
                return;
            }
            const prompt = `Generate 10 relevant and popular hashtags for a podcast with the following description: "${description}". Provide them as a comma-separated list, without any introductory text.`;
            callGeminiAPI(prompt, hashtagsLoadingSpinner, suggestedHashtagsTextarea);
        });


        generateVideoButton.addEventListener('click', async () => {
            if (!audioFile) {
                showErrorAlert('Please select an audio file or record one first.');
                return;
            }

            isGenerating = true;
            generateVideoButton.disabled = true;
            downloadSection.style.display = 'none';
            generationProgressContainer.style.display = 'block';
            progressBarFill.style.width = '0%';
            generationMessage.textContent = 'Preparing data...';
            messageElement.textContent = ''; // Clear general message

            const formData = new FormData();
            formData.append('audio', audioFile); // 'audio' is the field name for the audio file

            // Append other parameters
            formData.append('waveformStyle', waveformStyle);
            formData.append('waveformColor', waveformColor);
            formData.append('backgroundColor', backgroundColor);
            formData.append('backgroundOpacity', backgroundOpacity);
            formData.append('playbackSpeed', playbackSpeed); // Send playback speed to backend

            // Append background image if selected
            const selectedBackgroundImageFile = backgroundImageInput.files[0];
            if (selectedBackgroundImageFile) {
                formData.append('backgroundImage', selectedBackgroundImageFile); // 'backgroundImage' is the field name for the image file
            } else {
                formData.append('backgroundImage', ''); // Send an empty string if no image is selected
            }

            formData.append('textOverlay', textOverlay);

            try {
                // Simulate initial progress quickly
                progressBarFill.style.width = '20%';
                generationMessage.textContent = 'Sending data to server...';

                const response = await fetch('https://192.168.1.252:5000/api/v2/podcast/generate', {
                    method: 'POST',
                    body: formData,
                    // No 'Content-Type' header needed for FormData; browser sets it automatically
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: 'Unknown server error' }));
                    throw new Error(`Server error: ${response.status} - ${errorData.message || response.statusText}`);
                }

                // Simulate further progress
                progressBarFill.style.width = '70%';
                generationMessage.textContent = 'Processing video on server...';

                const result = await response.json(); // Assuming backend returns JSON with video_url

                // Simulate final progress
                progressBarFill.style.width = '100%';
                generationMessage.textContent = 'Video generation complete!';

                if (result && result.video_url) {
                    downloadLink.href = result.video_url;
                    // Dynamically set extension based on URL, default to mp4
                    downloadLink.download = `your_waveform_video.${result.video_url.split('.').pop() || 'mp4'}`;
                    downloadSection.style.display = 'block';
                    generationMessage.textContent = 'Video generated successfully! Click the link below to download.';
                } else {
                    // Fallback for unexpected response structure
                    downloadLink.href = 'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf'; // Fallback to dummy
                    downloadLink.download = 'your_waveform_video.mp4';
                    downloadSection.style.display = 'block';
                    generationMessage.textContent = 'Video generation completed, but no direct video URL received. Downloading dummy file.';
                }

            } catch (error) {
                console.error('Video generation failed:', error);
                showErrorAlert(`Error generating video: ${error.message}. Please check console for details.`);
                generationProgressContainer.style.display = 'none'; // Hide progress on error
                downloadSection.style.display = 'none'; // Hide download on error
            } finally {
                isGenerating = false;
                generateVideoButton.disabled = false;
            }
        });

        // Event listener for closing the error alert
        errorAlertCloseButton.addEventListener('click', hideErrorAlert);

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            // No audio is active on initial load. User must upload or record.
            // The audioPlayer element is just a placeholder in the HTML.
            // activeAudioElement will be set when loadUploadedAudio or loadRecordedAudio is called.
            updateCanvasDisplay(); // Initial draw of the canvas with default settings
        });

        // Cleanup on window unload (important for object URLs)
        window.addEventListener('beforeunload', () => {
            // Pause all audio elements
            if (audioPlayer) audioPlayer.pause();
            if (currentUploadedAudioElement) currentUploadedAudioElement.pause();
            if (currentRecordedAudioElement) currentRecordedAudioElement.pause();

            // Revoke all object URLs
            if (uploadedAudioUrl) URL.revokeObjectURL(uploadedAudioUrl);
            if (recordedAudioUrl) URL.revokeObjectURL(recordedAudioUrl);

            // Remove dynamically created audio elements from DOM
            if (currentUploadedAudioElement) currentUploadedAudioElement.remove();
            if (currentRecordedAudioElement) currentRecordedAudioElement.remove();

            // Close AudioContext and stop media stream
            if (audioContext) audioContext.close();
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
        });
    </script>
</body>
</html>
